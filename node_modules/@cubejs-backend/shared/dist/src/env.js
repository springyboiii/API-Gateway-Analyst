"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDockerImage = exports.getEnv = exports.asPortNumber = exports.convertTimeStrToMs = exports.InvalidConfiguration = void 0;
/* eslint-disable no-restricted-syntax */
const env_var_1 = require("env-var");
const cli_1 = require("./cli");
class InvalidConfiguration extends Error {
    constructor(key, value, description) {
        super(`Value "${value}" is not valid for ${key}. ${description}`);
    }
}
exports.InvalidConfiguration = InvalidConfiguration;
function convertTimeStrToMs(input, envName, description = 'Must be a number in seconds or duration string (1s, 1m, 1h).') {
    if (/^\d+$/.test(input)) {
        return parseInt(input, 10);
    }
    if (input.length > 1) {
        // eslint-disable-next-line default-case
        switch (input.slice(-1).toLowerCase()) {
            case 'h':
                return parseInt(input.slice(0, -1), 10) * 60 * 60;
            case 'm':
                return parseInt(input.slice(0, -1), 10) * 60;
            case 's':
                return parseInt(input.slice(0, -1), 10);
        }
    }
    throw new InvalidConfiguration(envName, input, description);
}
exports.convertTimeStrToMs = convertTimeStrToMs;
function asPortNumber(input, envName) {
    if (input < 0) {
        throw new InvalidConfiguration(envName, input, 'Should be a positive integer.');
    }
    if (input > 65535) {
        throw new InvalidConfiguration(envName, input, 'Should be lower or equal than 65535.');
    }
    return input;
}
exports.asPortNumber = asPortNumber;
function asPortOrSocket(input, envName) {
    if (/^-?\d+$/.test(input)) {
        return asPortNumber(parseInt(input, 10), envName);
    }
    // @todo Can we check that path for socket is valid?
    return input;
}
function asFalseOrPort(input, envName) {
    if (input.toLowerCase() === 'false' || input === '0' || input === undefined) {
        return false;
    }
    return asPortNumber(parseInt(input, 10), envName);
}
function asBoolOrTime(input, envName) {
    if (input.toLowerCase() === 'true') {
        return true;
    }
    if (input.toLowerCase() === 'false' || input === '0') {
        return false;
    }
    return convertTimeStrToMs(input, envName, 'Should be boolean or number (in seconds) or string in time format (1s, 1m, 1h)');
}
let legacyRedisPasswordAlerted = false;
let legacyRedisUrlAlerted = false;
let legacyRedisTlsAlerted = false;
const variables = {
    devMode: () => env_var_1.get('CUBEJS_DEV_MODE')
        .default('false')
        .asBoolStrict(),
    port: () => asPortOrSocket(process.env.PORT || '4000', 'PORT'),
    tls: () => env_var_1.get('CUBEJS_ENABLE_TLS')
        .default('false')
        .asBoolStrict(),
    webSockets: () => env_var_1.get('CUBEJS_WEB_SOCKETS')
        .default('false')
        .asBoolStrict(),
    rollupOnlyMode: () => env_var_1.get('CUBEJS_ROLLUP_ONLY')
        .default('false')
        .asBoolStrict(),
    refreshWorkerMode: () => {
        const refreshWorkerMode = env_var_1.get('CUBEJS_REFRESH_WORKER').asBool();
        if (refreshWorkerMode !== undefined) {
            return refreshWorkerMode;
        }
        // @deprecated Please use CUBEJS_REFRESH_WORKER
        const scheduledRefresh = env_var_1.get('CUBEJS_SCHEDULED_REFRESH').asBool();
        if (scheduledRefresh !== undefined) {
            return scheduledRefresh;
        }
        // @deprecated Please use CUBEJS_REFRESH_WORKER
        if (process.env.CUBEJS_SCHEDULED_REFRESH_TIMER) {
            return asBoolOrTime(process.env.CUBEJS_SCHEDULED_REFRESH_TIMER, 'CUBEJS_SCHEDULED_REFRESH_TIMER');
        }
        // It's true by default for development
        return process.env.NODE_ENV !== 'production';
    },
    preAggregationsBuilder: () => env_var_1.get('CUBEJS_PRE_AGGREGATIONS_BUILDER').asBool(),
    gracefulShutdown: () => env_var_1.get('CUBEJS_GRACEFUL_SHUTDOWN')
        .asIntPositive(),
    dockerImageVersion: () => env_var_1.get('CUBEJS_DOCKER_IMAGE_VERSION')
        .asString(),
    concurrency: () => env_var_1.get('CUBEJS_CONCURRENCY').asInt(),
    // It's only excepted for CI, nothing else.
    internalExceptions: () => env_var_1.get('INTERNAL_EXCEPTIONS_YOU_WILL_BE_FIRED')
        .default('false')
        .asEnum(['exit', 'log', 'false']),
    preAggregationsSchema: () => env_var_1.get('CUBEJS_PRE_AGGREGATIONS_SCHEMA')
        .asString(),
    dbPollTimeout: () => {
        const value = process.env.CUBEJS_DB_POLL_TIMEOUT;
        if (value) {
            return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_TIMEOUT');
        }
        else {
            return null;
        }
    },
    dbQueryTimeout: () => {
        const value = process.env.CUBEJS_DB_QUERY_TIMEOUT || '10m';
        return convertTimeStrToMs(value, 'CUBEJS_DB_QUERY_TIMEOUT');
    },
    dbPollMaxInterval: () => {
        const value = process.env.CUBEJS_DB_POLL_MAX_INTERVAL || '5s';
        return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_MAX_INTERVAL');
    },
    maxPartitionsPerCube: () => env_var_1.get('CUBEJS_MAX_PARTITIONS_PER_CUBE')
        .default('10000')
        .asInt(),
    // Common db options
    dbName: ({ required }) => env_var_1.get('CUBEJS_DB_NAME')
        .required(required)
        .asString(),
    // Export Bucket options
    dbExportBucketType: ({ supported }) => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_TYPE')
        .asEnum(supported),
    dbExportBucket: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET')
        .asString(),
    dbExportBucketMountDir: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_MOUNT_DIR')
        .asString(),
    // Export bucket options for AWS S3
    dbExportBucketAwsKey: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_KEY')
        .asString(),
    dbExportBucketAwsSecret: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_SECRET')
        .asString(),
    dbExportBucketAwsRegion: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_REGION')
        .asString(),
    // Export bucket options for Integration based
    dbExportIntegration: () => env_var_1.get('CUBEJS_DB_EXPORT_INTEGRATION')
        .asString(),
    // Export bucket options for GCS
    dbExportGCSCredentials: () => {
        const credentials = env_var_1.get('CUBEJS_DB_EXPORT_GCS_CREDENTIALS')
            .asString();
        if (credentials) {
            return JSON.parse(Buffer.from(credentials, 'base64').toString('utf8'));
        }
        return undefined;
    },
    // Export bucket options for Azure
    dbExportBucketAzureKey: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AZURE_KEY').asString(),
    // Redshift Driver
    dbExportBucketRedshiftArn: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_REDSHIFT_ARN')
        .asString(),
    // BigQuery Driver
    bigQueryLocation: () => env_var_1.get('CUBEJS_DB_BQ_LOCATION')
        .asString(),
    // Cube Store
    cubeStoreHost: () => env_var_1.get('CUBEJS_CUBESTORE_HOST')
        .asString(),
    cubeStorePort: () => env_var_1.get('CUBEJS_CUBESTORE_PORT')
        .asPortNumber(),
    cubeStoreUser: () => env_var_1.get('CUBEJS_CUBESTORE_USER')
        .asString(),
    cubeStorePass: () => env_var_1.get('CUBEJS_CUBESTORE_PASS')
        .asString(),
    // Databricks
    databrickUrl: () => env_var_1.get('CUBEJS_DB_DATABRICKS_URL')
        .required()
        .asString(),
    databrickToken: () => env_var_1.get('CUBEJS_DB_DATABRICKS_TOKEN')
        .asString(),
    databrickAcceptPolicy: () => env_var_1.get('CUBEJS_DB_DATABRICKS_ACCEPT_POLICY')
        .asBoolStrict(),
    // Redis
    redisPoolMin: () => env_var_1.get('CUBEJS_REDIS_POOL_MIN')
        .default('2')
        .asInt(),
    redisPoolMax: () => env_var_1.get('CUBEJS_REDIS_POOL_MAX')
        .default('1000')
        .asInt(),
    redisUseIORedis: () => env_var_1.get('CUBEJS_REDIS_USE_IOREDIS')
        .default('false')
        .asBoolStrict(),
    allowUngroupedWithoutPrimaryKey: () => env_var_1.get('CUBEJS_ALLOW_UNGROUPED_WITHOUT_PRIMARY_KEY')
        .default('false')
        .asBoolStrict(),
    redisPassword: () => {
        const redisPassword = env_var_1.get('CUBEJS_REDIS_PASSWORD')
            .asString();
        if (redisPassword) {
            return redisPassword;
        }
        const legacyRedisPassword = env_var_1.get('REDIS_PASSWORD')
            .asString();
        if (legacyRedisPassword) {
            if (!legacyRedisPasswordAlerted) {
                cli_1.displayCLIWarning('REDIS_PASSWORD is deprecated and will be removed, please use CUBEJS_REDIS_PASSWORD.');
                legacyRedisPasswordAlerted = true;
            }
            return legacyRedisPassword;
        }
        return undefined;
    },
    redisUrl: () => {
        const redisUrl = env_var_1.get('CUBEJS_REDIS_URL')
            .asString();
        if (redisUrl) {
            return redisUrl;
        }
        const legacyRedisUrl = env_var_1.get('REDIS_URL')
            .asString();
        if (legacyRedisUrl) {
            if (!legacyRedisUrlAlerted) {
                cli_1.displayCLIWarning('REDIS_URL is deprecated and will be removed, please use CUBEJS_REDIS_URL.');
                legacyRedisUrlAlerted = true;
            }
            return legacyRedisUrl;
        }
        return undefined;
    },
    redisTls: () => {
        const redisTls = env_var_1.get('CUBEJS_REDIS_TLS')
            .asBoolStrict();
        if (redisTls) {
            return redisTls;
        }
        const legacyRedisTls = env_var_1.get('REDIS_TLS')
            .asBoolStrict();
        if (legacyRedisTls) {
            if (!legacyRedisTlsAlerted) {
                cli_1.displayCLIWarning('REDIS_TLS is deprecated and will be removed, please use CUBEJS_REDIS_TLS.');
                legacyRedisTlsAlerted = true;
            }
            return legacyRedisTls;
        }
        return false;
    },
    dbSsl: () => env_var_1.get('CUBEJS_DB_SSL')
        .default('false')
        .asBoolStrict(),
    dbSslRejectUnauthorized: () => env_var_1.get('CUBEJS_DB_SSL_REJECT_UNAUTHORIZED')
        .default('false')
        .asBoolStrict(),
    nodeEnv: () => env_var_1.get('NODE_ENV')
        .asString(),
    cacheAndQueueDriver: () => env_var_1.get('CUBEJS_CACHE_AND_QUEUE_DRIVER')
        .asString(),
    jwkUrl: () => env_var_1.get('CUBEJS_JWK_URL')
        .asString(),
    jwtKey: () => env_var_1.get('CUBEJS_JWT_KEY')
        .asString(),
    jwtAlgorithms: () => env_var_1.get('CUBEJS_JWT_ALGS')
        .asArray(','),
    jwtAudience: () => env_var_1.get('CUBEJS_JWT_AUDIENCE')
        .asString(),
    jwtIssuer: () => env_var_1.get('CUBEJS_JWT_ISSUER')
        .asArray(','),
    jwtSubject: () => env_var_1.get('CUBEJS_JWT_SUBJECT')
        .asString(),
    jwtClaimsNamespace: () => env_var_1.get('CUBEJS_JWT_CLAIMS_NAMESPACE')
        .asString(),
    playgroundAuthSecret: () => env_var_1.get('CUBEJS_PLAYGROUND_AUTH_SECRET')
        .asString(),
    agentFrameSize: () => env_var_1.get('CUBEJS_AGENT_FRAME_SIZE')
        .default('200')
        .asInt(),
    agentEndpointUrl: () => env_var_1.get('CUBEJS_AGENT_ENDPOINT_URL')
        .asString(),
    agentFlushInterval: () => env_var_1.get('CUBEJS_AGENT_FLUSH_INTERVAL')
        .default(1000)
        .asInt(),
    agentMaxSockets: () => env_var_1.get('CUBEJS_AGENT_MAX_SOCKETS')
        .default(100)
        .asInt(),
    instanceId: () => env_var_1.get('CUBEJS_INSTANCE_ID')
        .asString(),
    telemetry: () => env_var_1.get('CUBEJS_TELEMETRY')
        .default('true')
        .asBool(),
    // SQL Interface
    sqlPort: () => {
        const port = asFalseOrPort(process.env.CUBEJS_SQL_PORT || 'false', 'CUBEJS_SQL_PORT');
        if (port) {
            return port;
        }
        return undefined;
    },
    pgSqlPort: () => {
        const port = asFalseOrPort(process.env.CUBEJS_PG_SQL_PORT || 'false', 'CUBEJS_PG_SQL_PORT');
        if (port) {
            return port;
        }
        return undefined;
    },
    sqlNonce: () => {
        if (process.env.CUBEJS_SQL_NONCE) {
            if (process.env.CUBEJS_SQL_NONCE.length < 14) {
                throw new InvalidConfiguration('CUBEJS_SQL_NONCE', process.env.CUBEJS_SQL_NONCE, 'Is too short. It should be 14 chars at least.');
            }
            return process.env.CUBEJS_SQL_NONCE;
        }
        return undefined;
    },
    sqlUser: () => env_var_1.get('CUBEJS_SQL_USER').asString(),
    sqlPassword: () => env_var_1.get('CUBEJS_SQL_PASSWORD').asString(),
    sqlSuperUser: () => env_var_1.get('CUBEJS_SQL_SUPER_USER').asString(),
    // Experiments & Preview flags
    livePreview: () => env_var_1.get('CUBEJS_LIVE_PREVIEW')
        .default('true')
        .asBoolStrict(),
    preAggregationsQueueEventsBus: () => env_var_1.get('CUBEJS_PRE_AGGREGATIONS_QUEUE_EVENTS_BUS')
        .default('false')
        .asBoolStrict(),
    externalDefault: () => env_var_1.get('CUBEJS_EXTERNAL_DEFAULT')
        .default('true')
        .asBoolStrict(),
    scheduledRefreshDefault: () => env_var_1.get('CUBEJS_SCHEDULED_REFRESH_DEFAULT').default('true').asBoolStrict(),
    previewFeatures: () => env_var_1.get('CUBEJS_PREVIEW_FEATURES')
        .default('false')
        .asBoolStrict(),
    batchingRowSplitCount: () => env_var_1.get('CUBEJS_BATCHING_ROW_SPLIT_COUNT')
        .default(256 * 1024)
        .asInt(),
    maxSourceRowLimit: () => env_var_1.get('CUBEJS_MAX_SOURCE_ROW_LIMIT')
        .default(200000)
        .asInt()
};
function getEnv(key, opts) {
    if (key in variables) {
        return variables[key](opts);
    }
    throw new Error(`Unsupported env variable: "${key}"`);
}
exports.getEnv = getEnv;
function isDockerImage() {
    return Boolean(process.env.CUBEJS_DOCKER_IMAGE_TAG);
}
exports.isDockerImage = isDockerImage;
//# sourceMappingURL=env.js.map