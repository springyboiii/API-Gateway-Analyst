"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncRetry = exports.asyncMemoizeBackground = exports.decorateWithCancel = exports.asyncMemoize = exports.asyncDebounce = exports.retryWithTimeout = exports.withTimeoutRace = exports.withTimeout = exports.createCancelableInterval = exports.createCancelablePromise = exports.pausePromise = void 0;
/* eslint-disable arrow-body-style,no-restricted-syntax */
const crypto_1 = __importDefault(require("crypto"));
function pausePromise(ms) {
    let cancel = () => {
        //
    };
    const promise = new Promise((resolve) => {
        const timeout = setTimeout(resolve, ms);
        cancel = () => {
            clearTimeout(timeout);
            resolve();
        };
    });
    promise.cancel = cancel;
    return promise;
}
exports.pausePromise = pausePromise;
class CancelToken {
    constructor() {
        this.deferred = [];
        this.withQueue = [];
        this.canceled = false;
    }
    async cancel() {
        if (this.canceled) {
            throw new Error('CancelToken was already canceled');
        }
        this.canceled = true;
        if (this.deferred.length) {
            await Promise.all(this.deferred.map(async (queued) => queued()));
        }
        if (this.withQueue.length) {
            await Promise.all(this.withQueue.map((cb) => cb()));
        }
    }
    defer(fn) {
        this.deferred.push(fn);
    }
    async with(fn) {
        if (fn.cancel) {
            this.withQueue.push(fn.cancel);
        }
        return fn;
    }
    isCanceled() {
        return this.canceled;
    }
}
function createCancelablePromise(fn) {
    const token = new CancelToken();
    const promise = fn(token);
    promise.cancel = async (waitExecution = true) => {
        const locks = [
            token.cancel(),
        ];
        if (waitExecution) {
            locks.push(promise);
        }
        return Promise.all(locks);
    };
    return promise;
}
exports.createCancelablePromise = createCancelablePromise;
/**
 * It's helps to create an interval that can be canceled with awaiting latest execution
 */
function createCancelableInterval(fn, options) {
    let execution = null;
    let startTime = null;
    let intervalId = 0;
    let duplicatedExecutionTracked = false;
    const timeout = setInterval(async () => {
        if (execution) {
            if (options.onDuplicatedExecution) {
                duplicatedExecutionTracked = true;
                options.onDuplicatedExecution(intervalId);
            }
            return;
        }
        try {
            intervalId++;
            if (intervalId >= Number.MAX_SAFE_INTEGER) {
                intervalId = 0;
            }
            startTime = Date.now();
            execution = createCancelablePromise(fn);
            await execution;
        }
        finally {
            execution = null;
            if (duplicatedExecutionTracked && options.onDuplicatedStateResolved) {
                options.onDuplicatedStateResolved(intervalId, Date.now() - startTime);
            }
            duplicatedExecutionTracked = false;
        }
    }, options.interval);
    return {
        cancel: async (waitExecution = true) => {
            clearInterval(timeout);
            if (execution) {
                await execution.cancel(waitExecution);
            }
        }
    };
}
exports.createCancelableInterval = createCancelableInterval;
const withTimeout = (fn, timeout) => {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    let cancel = () => { };
    const promise = new Promise((resolve) => {
        const timer = setTimeout(() => {
            fn();
            resolve();
        }, timeout);
        cancel = () => {
            clearTimeout(timer);
            resolve();
        };
    });
    promise.cancel = cancel;
    return promise;
};
exports.withTimeout = withTimeout;
const withTimeoutRace = (fn, timeout) => {
    let timer = null;
    return Promise.race([
        fn,
        new Promise((resolve, reject) => {
            timer = setTimeout(async () => {
                await fn.cancel(false);
                reject(new Error(`Timeout reached after ${timeout}ms`));
            }, timeout);
            fn.then(resolve).catch(reject);
        })
    ]).then((v) => {
        if (timer) {
            clearTimeout(timer);
        }
        return v;
    }, (err) => {
        if (timer) {
            clearTimeout(timer);
        }
        throw err;
    });
};
exports.withTimeoutRace = withTimeoutRace;
const retryWithTimeout = (fn, { timeout, intervalPause }) => exports.withTimeoutRace(createCancelablePromise(async (token) => {
    let i = 0;
    while (!token.isCanceled()) {
        i++;
        const result = await fn(token);
        if (result) {
            return result;
        }
        await token.with(pausePromise(intervalPause(i)));
    }
    return null;
}), timeout);
exports.retryWithTimeout = retryWithTimeout;
/**
 * High order function that makes to debounce multi async calls to single call at one time
 */
const asyncDebounce = (fn) => {
    const cache = new Map();
    return async (...args) => {
        const key = crypto_1.default.createHash('md5')
            .update(args.map((v) => JSON.stringify(v)).join(','))
            .digest('hex');
        if (cache.has(key)) {
            return cache.get(key);
        }
        try {
            const promise = fn(...args);
            cache.set(key, promise);
            return await promise;
        }
        finally {
            cache.delete(key);
        }
    };
};
exports.asyncDebounce = asyncDebounce;
const asyncMemoize = (fn, options) => {
    const cache = new Map();
    const debouncedFn = exports.asyncDebounce(fn);
    const call = async (...args) => {
        const key = options.extractKey(...args);
        if (cache.has(key)) {
            const bucket = cache.get(key);
            if (bucket.lifetime >= Date.now()) {
                return bucket.item;
            }
            else {
                cache.delete(key);
            }
        }
        const item = await debouncedFn(...args);
        cache.set(key, {
            lifetime: Date.now() + options.extractCacheLifetime(item),
            item,
        });
        return item;
    };
    call.force = async (...args) => {
        const key = options.extractKey(...args);
        const item = await debouncedFn(...args);
        cache.set(key, {
            lifetime: Date.now() + options.extractCacheLifetime(item),
            item,
        });
        return item;
    };
    return call;
};
exports.asyncMemoize = asyncMemoize;
const decorateWithCancel = (fn, cancel) => {
    fn.cancel = cancel;
    return fn;
};
exports.decorateWithCancel = decorateWithCancel;
const asyncMemoizeBackground = (fn, options) => {
    const cache = new Map();
    const debouncedFn = exports.asyncDebounce(fn);
    const refreshBucket = async (bucket) => {
        try {
            const item = await debouncedFn(...bucket.args);
            bucket.item = item;
            bucket.lifetime = Date.now() + options.extractCacheLifetime(item);
        }
        catch (e) {
            options.onBackgroundException(e);
        }
    };
    const refreshInterval = createCancelableInterval(async () => {
        const refreshBatch = [];
        const now = Date.now();
        for (const bucket of cache.values()) {
            if (bucket.lifetime < now) {
                refreshBatch.push(refreshBucket(bucket));
            }
        }
        return Promise.all(refreshBatch);
    }, {
        interval: options.backgroundRefreshInterval,
    });
    const call = async (...args) => {
        const key = options.extractKey(...args);
        if (cache.has(key)) {
            // If cache exists, only background timer or force can update it.
            return cache.get(key).item;
        }
        const item = await debouncedFn(...args);
        cache.set(key, {
            lifetime: Date.now() + options.extractCacheLifetime(item),
            args,
            item,
        });
        return item;
    };
    call.force = async (...args) => {
        const key = options.extractKey(...args);
        const item = await debouncedFn(...args);
        cache.set(key, {
            lifetime: Date.now() + options.extractCacheLifetime(item),
            args,
            item,
        });
        return item;
    };
    call.release = refreshInterval.cancel;
    return call;
};
exports.asyncMemoizeBackground = asyncMemoizeBackground;
/**
 * High order function that do retry when async function throw an exception
 */
const asyncRetry = async (fn, options) => {
    if (options.times <= 0) {
        throw new Error('Option times in asyncRetry, must be a positive integer');
    }
    let latestException = null;
    for (let i = 0; i < options.times; i++) {
        try {
            return await fn();
        }
        catch (e) {
            latestException = e;
        }
    }
    throw latestException;
};
exports.asyncRetry = asyncRetry;
//# sourceMappingURL=promises.js.map