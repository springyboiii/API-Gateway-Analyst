"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSecondsToLocalTimestamp = exports.extractDate = exports.utcToLocalTimeZone = exports.inDbTimeZone = exports.BUILD_RANGE_END_LOCAL = exports.BUILD_RANGE_START_LOCAL = exports.TO_PARTITION_RANGE = exports.FROM_PARTITION_RANGE = exports.timeSeries = exports.TIME_SERIES = void 0;
const moment_range_1 = require("moment-range");
const Moment = require('moment-timezone');
const moment = moment_range_1.extendMoment(Moment);
exports.TIME_SERIES = {
    day: (range) => Array.from(range.snapTo('day').by('day'))
        .map(d => [d.format('YYYY-MM-DDT00:00:00.000'), d.format('YYYY-MM-DDT23:59:59.999')]),
    month: (range) => Array.from(range.snapTo('month').by('month'))
        .map(d => [d.format('YYYY-MM-01T00:00:00.000'), d.endOf('month').format('YYYY-MM-DDT23:59:59.999')]),
    year: (range) => Array.from(range.snapTo('year').by('year'))
        .map(d => [d.format('YYYY-01-01T00:00:00.000'), d.endOf('year').format('YYYY-MM-DDT23:59:59.999')]),
    hour: (range) => Array.from(range.snapTo('hour').by('hour'))
        .map(d => [d.format('YYYY-MM-DDTHH:00:00.000'), d.format('YYYY-MM-DDTHH:59:59.999')]),
    minute: (range) => Array.from(range.snapTo('minute').by('minute'))
        .map(d => [d.format('YYYY-MM-DDTHH:mm:00.000'), d.format('YYYY-MM-DDTHH:mm:59.999')]),
    second: (range) => Array.from(range.snapTo('second').by('second'))
        .map(d => [d.format('YYYY-MM-DDTHH:mm:ss.000'), d.format('YYYY-MM-DDTHH:mm:ss.999')]),
    week: (range) => Array.from(range.snapTo('isoWeek').by('week'))
        .map(d => [d.startOf('isoWeek').format('YYYY-MM-DDT00:00:00.000'), d.endOf('isoWeek').format('YYYY-MM-DDT23:59:59.999')]),
    quarter: (range) => Array.from(range.snapTo('quarter').by('quarter'))
        .map(d => [d.format('YYYY-MM-DDT00:00:00.000'), d.endOf('quarter').format('YYYY-MM-DDT23:59:59.999')]),
};
const timeSeries = (granularity, dateRange) => {
    if (!exports.TIME_SERIES[granularity]) {
        // TODO error
        throw new Error(`Unsupported time granularity: ${granularity}`);
    }
    // moment.range works with strings
    const range = moment.range(dateRange[0], dateRange[1]);
    return exports.TIME_SERIES[granularity](range);
};
exports.timeSeries = timeSeries;
exports.FROM_PARTITION_RANGE = '__FROM_PARTITION_RANGE';
exports.TO_PARTITION_RANGE = '__TO_PARTITION_RANGE';
exports.BUILD_RANGE_START_LOCAL = '__BUILD_RANGE_START_LOCAL';
exports.BUILD_RANGE_END_LOCAL = '__BUILD_RANGE_END_LOCAL';
const inDbTimeZone = (timezone, timestampFormat, timestamp) => {
    if (timestamp.length === 23) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        const offset = zone.utcOffset(parsedTime);
        const inDbTimeZoneDate = new Date(parsedTime + offset * 60 * 1000);
        if (timestampFormat === 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' || timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSZ') {
            return inDbTimeZoneDate.toJSON();
        }
        else if (timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSS') {
            return inDbTimeZoneDate.toJSON().replace('Z', '');
        }
    }
    return moment.tz(timestamp, timezone).utc().format(timestampFormat);
};
exports.inDbTimeZone = inDbTimeZone;
const utcToLocalTimeZone = (timezone, timestampFormat, timestamp) => {
    if (timestamp.length === 23) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        // TODO parsedTime might be incorrect offset for conversion
        const offset = zone.utcOffset(parsedTime);
        const inDbTimeZoneDate = new Date(parsedTime - offset * 60 * 1000);
        if (timestampFormat === 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' || timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSSZ') {
            return inDbTimeZoneDate.toJSON();
        }
        else if (timestampFormat === 'YYYY-MM-DDTHH:mm:ss.SSS') {
            return inDbTimeZoneDate.toJSON().replace('Z', '');
        }
    }
    return moment.tz(timestamp, 'UTC').tz(timezone).format(timestampFormat);
};
exports.utcToLocalTimeZone = utcToLocalTimeZone;
const extractDate = (data) => {
    data = JSON.parse(JSON.stringify(data));
    const value = data[0] && data[0][Object.keys(data[0])[0]];
    if (!value) {
        return value;
    }
    return moment.tz(value, 'UTC').utc().format(moment.HTML5_FMT.DATETIME_LOCAL_MS);
};
exports.extractDate = extractDate;
const addSecondsToLocalTimestamp = (timestamp, timezone, seconds) => {
    if (timestamp.length === 23) {
        const zone = moment.tz.zone(timezone);
        if (!zone) {
            throw new Error(`Unknown timezone: ${timezone}`);
        }
        const parsedTime = Date.parse(`${timestamp}Z`);
        const offset = zone.utcOffset(parsedTime);
        return new Date(parsedTime + offset * 60 * 1000 + seconds * 1000);
    }
    return moment.tz(timestamp, timezone)
        .add(seconds, 'second')
        .toDate();
};
exports.addSecondsToLocalTimestamp = addSecondsToLocalTimestamp;
//# sourceMappingURL=time.js.map