import { Optional } from './type-helpers';
declare type CancelablePromiseCancel = (waitExecution?: boolean) => Promise<any>;
export interface CancelablePromise<T> extends Promise<T> {
    cancel: CancelablePromiseCancel;
}
export declare type MaybeCancelablePromise<T> = Optional<CancelablePromise<T>, 'cancel'>;
export declare function pausePromise(ms: number): CancelablePromise<void>;
declare class CancelToken {
    protected readonly deferred: (() => Promise<void> | void)[];
    protected readonly withQueue: CancelablePromiseCancel[];
    protected canceled: boolean;
    cancel(): Promise<void>;
    defer(fn: () => Promise<void> | void): void;
    with<T = any>(fn: MaybeCancelablePromise<T>): Promise<T>;
    isCanceled(): boolean;
}
export declare function createCancelablePromise<T>(fn: (cancel: CancelToken) => Promise<T>): CancelablePromise<T>;
export interface CancelableInterval {
    cancel: (waitExecution?: boolean) => Promise<void>;
}
export interface CancelableIntervalOptions {
    interval: number;
    onDuplicatedStateResolved?: (intervalId: number, elapsedTime: number) => any;
    onDuplicatedExecution?: (intervalId: number) => any;
}
/**
 * It's helps to create an interval that can be canceled with awaiting latest execution
 */
export declare function createCancelableInterval<T>(fn: (token: CancelToken) => Promise<T>, options: CancelableIntervalOptions): CancelableInterval;
interface RetryWithTimeoutOptions {
    timeout: number;
    intervalPause: (iteration: number) => number;
}
export declare const withTimeout: (fn: (...args: any[]) => void, timeout: number) => CancelablePromise<any>;
export declare const withTimeoutRace: <T>(fn: CancelablePromise<T>, timeout: number) => Promise<T>;
export declare const retryWithTimeout: <T>(fn: (token: CancelToken) => Promise<T>, { timeout, intervalPause }: RetryWithTimeoutOptions) => Promise<T | null>;
/**
 * High order function that makes to debounce multi async calls to single call at one time
 */
export declare const asyncDebounce: <Ret, Arguments>(fn: (...args: Arguments[]) => Promise<Ret>) => (...args: Arguments[]) => Promise<Ret>;
export declare type MemoizeOptions<Ret, Arguments> = {
    extractKey: (...args: Arguments[]) => string;
    extractCacheLifetime: (result: Ret) => number;
};
export declare const asyncMemoize: <Ret, Arguments>(fn: (...args: Arguments[]) => Promise<Ret>, options: MemoizeOptions<Ret, Arguments>) => {
    (...args: Arguments[]): Promise<Ret>;
    force(...args: Arguments[]): Promise<Ret>;
};
export declare type BackgroundMemoizeOptions<Ret, Arguments> = {
    extractKey: (...args: Arguments[]) => string;
    extractCacheLifetime: (result: Ret) => number;
    backgroundRefreshInterval: number;
    onBackgroundException: (err: Error) => void;
};
export declare const decorateWithCancel: <T, C = () => void>(fn: Promise<T>, cancel: C) => CancelablePromise<T>;
export declare const asyncMemoizeBackground: <Ret, Arguments>(fn: (...args: Arguments[]) => Promise<Ret>, options: BackgroundMemoizeOptions<Ret, Arguments>) => {
    (...args: Arguments[]): Promise<Ret>;
    force(...args: Arguments[]): Promise<Ret>;
    release: (waitExecution?: boolean | undefined) => Promise<void>;
};
export declare type RetryOptions = {
    times: number;
};
/**
 * High order function that do retry when async function throw an exception
 */
export declare const asyncRetry: <Ret>(fn: () => Promise<Ret>, options: RetryOptions) => Promise<Ret>;
export {};
//# sourceMappingURL=promises.d.ts.map