"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.track = exports.getAnonymousId = void 0;
const crypto_1 = __importDefault(require("crypto"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const machine_id_1 = require("./machine-id");
const errors_1 = require("./errors");
let flushPromise = null;
let trackEvents = [];
async function flush(toFlush, retries = 10) {
    if (!toFlush) {
        toFlush = trackEvents;
        trackEvents = [];
    }
    if (!toFlush.length) {
        return;
    }
    try {
        const sentAt = new Date().toJSON();
        const result = await node_fetch_1.default('https://track.cube.dev/track', {
            method: 'post',
            body: JSON.stringify(toFlush.map(r => ({ ...r, sentAt }))),
            headers: { 'Content-Type': 'application/json' },
        });
        if (result.status !== 200 && retries > 0) {
            errors_1.internalExceptions(new Error(`Probably an unexpected request caused a bad response: ${result.status}`));
            // eslint-disable-next-line consistent-return
            return flush(toFlush, retries - 1);
        }
        // console.log(await result.json());
    }
    catch (e) {
        if (retries > 0) {
            // eslint-disable-next-line consistent-return
            return flush(toFlush, retries - 1);
        }
        errors_1.internalExceptions(e);
    }
}
let anonymousId = 'unknown';
try {
    anonymousId = machine_id_1.machineIdSync();
}
catch (e) {
    errors_1.internalExceptions(e);
}
function getAnonymousId() {
    return anonymousId;
}
exports.getAnonymousId = getAnonymousId;
async function track(opts) {
    // fixes the issue with async tests
    // the promise returned from this function can be executed after the test has finished
    if (process.env.CI) {
        return Promise.resolve();
    }
    trackEvents.push({
        ...opts,
        id: crypto_1.default.randomBytes(16).toString('hex'),
        clientTimestamp: new Date().toJSON(),
        platform: process.platform,
        arch: process.arch,
        nodeVersion: process.version,
        anonymousId,
        sentFrom: 'backend'
    });
    const currentPromise = (flushPromise || Promise.resolve()).then(() => flush()).then(() => {
        if (currentPromise === flushPromise) {
            flushPromise = null;
        }
    });
    flushPromise = currentPromise;
    return flushPromise;
}
exports.track = track;
//# sourceMappingURL=track.js.map