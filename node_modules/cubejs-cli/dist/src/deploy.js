"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployDirectory = void 0;
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
class DeployDirectory {
    constructor(options) {
        this.options = options;
    }
    async fileHashes(directory = this.options.directory) {
        let result = {};
        const files = await fs_extra_1.default.readdir(directory);
        // eslint-disable-next-line no-restricted-syntax
        for (const file of files) {
            const filePath = path_1.default.resolve(directory, file);
            if (!this.filter(filePath)) {
                // eslint-disable-next-line no-continue
                continue;
            }
            const stat = await fs_extra_1.default.stat(filePath);
            if (stat.isDirectory()) {
                result = { ...result, ...await this.fileHashes(filePath) };
            }
            else {
                result[path_1.default.relative(this.options.directory, filePath)] = {
                    hash: await this.fileHash(filePath)
                };
            }
        }
        return result;
    }
    filter(file) {
        const baseName = path_1.default.basename(file);
        // whitelist
        if (['.gitignore'].includes(baseName)) {
            return true;
        }
        // blacklist
        if (['dashboard-app', 'node_modules'].includes(baseName)) {
            return false;
        }
        return baseName.charAt(0) !== '.';
    }
    fileHash(file) {
        return new Promise((resolve, reject) => {
            const hash = crypto_1.default.createHash('sha1');
            const stream = fs_extra_1.default.createReadStream(file);
            stream.on('error', err => reject(err));
            stream.on('data', chunk => hash.update(chunk));
            stream.on('end', () => resolve(hash.digest('hex')));
        });
    }
}
exports.DeployDirectory = DeployDirectory;
//# sourceMappingURL=deploy.js.map