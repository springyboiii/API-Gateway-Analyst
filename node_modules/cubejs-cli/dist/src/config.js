"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const inquirer_1 = __importDefault(require("inquirer"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const request_promise_1 = __importDefault(require("request-promise"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const dotenv_1 = __importDefault(require("@cubejs-backend/dotenv"));
const shared_1 = require("@cubejs-backend/shared");
const utils_1 = require("./utils");
class Config {
    async loadConfig() {
        const { configFile } = this.configFile();
        if (await fs_extra_1.default.pathExists(configFile)) {
            return fs_extra_1.default.readJson(configFile);
        }
        return {};
    }
    async writeConfig(config) {
        const { cubeCloudConfigPath, configFile } = this.configFile();
        await fs_extra_1.default.mkdirp(cubeCloudConfigPath);
        await fs_extra_1.default.writeJson(configFile, config);
    }
    configFile() {
        const cubeCloudConfigPath = this.cubeCloudConfigPath();
        const configFile = path_1.default.join(cubeCloudConfigPath, 'config.json');
        return { cubeCloudConfigPath, configFile };
    }
    async envFile(envFile) {
        if (await fs_extra_1.default.pathExists(envFile)) {
            const env = dotenv_1.default.config({ path: envFile, multiline: 'line-breaks' }).parsed;
            if (env) {
                if ('CUBEJS_DEV_MODE' in env) {
                    delete env.CUBEJS_DEV_MODE;
                }
                const resolvePossibleFiles = [
                    'CUBEJS_DB_SSL_CA',
                    'CUBEJS_DB_SSL_CERT',
                    'CUBEJS_DB_SSL_KEY',
                ];
                // eslint-disable-next-line no-restricted-syntax
                for (const [key, value] of Object.entries(env)) {
                    if (resolvePossibleFiles.includes(key) && shared_1.isFilePath(value)) {
                        if (fs_extra_1.default.existsSync(value)) {
                            env[key] = fs_extra_1.default.readFileSync(value, 'ascii');
                        }
                        else {
                            utils_1.displayWarning(`Unable to resolve file "${value}" from ${key}`);
                            env[key] = '';
                        }
                    }
                }
                return env;
            }
        }
        return {};
    }
    cubeEnvConfigPath() {
        return path_1.default.join(os_1.default.homedir(), '.env');
    }
    cubeCloudConfigPath() {
        return path_1.default.join(os_1.default.homedir(), '.cubecloud');
    }
    async deployAuth(url) {
        const config = await this.loadConfig();
        if (process.env.CUBE_CLOUD_DEPLOY_AUTH) {
            return (await this.addAuthToken(process.env.CUBE_CLOUD_DEPLOY_AUTH, config)).auth;
        }
        if (config.auth) {
            return config.auth;
        }
        const auth = await inquirer_1.default.prompt([{
                name: 'auth',
                message: `Cube Cloud Auth Token${url ? ` for ${url}` : ''}`
            }]);
        return (await this.addAuthToken(auth.auth, config)).auth;
    }
    async addAuthToken(authToken, config) {
        if (!config) {
            config = await this.loadConfig();
        }
        const payload = jsonwebtoken_1.default.decode(authToken);
        if (payload && typeof payload === 'object' && payload.url) {
            config.auth = config.auth || {};
            config.auth[payload.url] = {
                auth: authToken
            };
            if (payload.deploymentId) {
                const dotCubeCloud = await this.loadDotCubeCloud();
                dotCubeCloud.url = payload.url;
                dotCubeCloud.deploymentId = payload.deploymentId;
                await this.writeDotCubeCloud(dotCubeCloud);
            }
            await this.writeConfig(config);
            return config;
        }
        const answer = await this.cloudTokenReq(authToken);
        if (answer) {
            return this.addAuthToken(answer, config);
        }
        // eslint-disable-next-line no-throw-literal
        throw 'Malformed Cube Cloud token';
    }
    async deployAuthForCurrentDir() {
        const dotCubeCloud = await this.loadDotCubeCloud();
        if (dotCubeCloud.url && dotCubeCloud.deploymentId) {
            const deployAuth = await this.deployAuth(dotCubeCloud.url);
            if (!deployAuth[dotCubeCloud.url]) {
                throw new Error(`Provided token isn't for ${dotCubeCloud.url}`);
            }
            return {
                ...deployAuth[dotCubeCloud.url],
                url: dotCubeCloud.url,
                deploymentId: dotCubeCloud.deploymentId
            };
        }
        const auth = await this.deployAuth();
        let url = Object.keys(auth)[0];
        if (Object.keys(auth).length > 1) {
            // eslint-disable-next-line prefer-destructuring
            url = (await inquirer_1.default.prompt([{
                    type: 'list',
                    name: 'url',
                    message: 'Please select an organization',
                    choices: Object.keys(auth)
                }])).url;
        }
        const authToken = auth[url];
        const deployments = await this.cloudReq({
            url: () => 'build/deploy/deployments',
            method: 'GET',
            auth: { ...authToken, url }
        });
        if (!Array.isArray(deployments)) {
            throw new Error(deployments.toString());
        }
        if (!deployments.length) {
            // eslint-disable-next-line no-throw-literal
            throw `${url} doesn't have any managed deployments. Please create one.`;
        }
        let deploymentId = deployments[0].id;
        if (deployments.length > 1) {
            const { deployment } = await inquirer_1.default.prompt([{
                    type: 'list',
                    name: 'deployment',
                    message: 'Please select a deployment to deploy to',
                    choices: deployments
                }]);
            deploymentId = deployments.find(d => d.name === deployment).id;
        }
        await this.writeDotCubeCloud({
            url,
            deploymentId
        });
        return {
            ...authToken,
            url,
            deploymentId
        };
    }
    dotCubeCloudFile() {
        return '.cubecloud';
    }
    async loadDotCubeCloud() {
        if (await fs_extra_1.default.pathExists(this.dotCubeCloudFile())) {
            return fs_extra_1.default.readJson(this.dotCubeCloudFile());
        }
        return {};
    }
    async writeDotCubeCloud(config) {
        await fs_extra_1.default.writeJson(this.dotCubeCloudFile(), config);
    }
    async cloudReq(options) {
        const { url, auth, ...restOptions } = options;
        const authorization = auth || await this.deployAuthForCurrentDir();
        if (!authorization) {
            throw new Error('Auth isn\'t set');
        }
        return request_promise_1.default({
            headers: {
                authorization: authorization.auth
            },
            ...restOptions,
            url: `${authorization.url}/${url(authorization.deploymentId)}`,
            json: true
        });
    }
    async cloudTokenReq(authToken) {
        const res = await request_promise_1.default({
            url: `${process.env.CUBE_CLOUD_HOST || 'https://cubecloud.dev'}/v1/token`,
            method: 'POST',
            headers: {
                'Content-type': 'application/json'
            },
            json: true,
            body: {
                token: authToken
            }
        });
        if (res && res.error) {
            throw res.error;
        }
        return res.jwt;
    }
}
exports.Config = Config;
//# sourceMappingURL=config.js.map